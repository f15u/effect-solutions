#!/usr/bin/env node
import { promises as fs } from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, "..");
const referencesDir = path.join(rootDir, "packages", "website", "references");
const manifestPath = path.join(
  rootDir,
  "packages",
  "cli",
  "src",
  "reference-manifest.ts",
);
const manifestDir = path.dirname(manifestPath);
const skillPath = path.join(rootDir, "SKILL.md");

const SKILL_TABLE_START = "<!-- SKILL_TABLE_START -->";
const SKILL_TABLE_END = "<!-- SKILL_TABLE_END -->";

async function collectMarkdownFiles(dir, prefix = "") {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];

  for (const entry of entries) {
    const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;
    const absolutePath = path.join(dir, entry.name);

    if (entry.isDirectory()) {
      files.push(...(await collectMarkdownFiles(absolutePath, relativePath)));
    } else if (/\.(md|mdx)$/i.test(entry.name)) {
      files.push(relativePath);
    }
  }

  return files;
}

const toIdentifier = (fileName) => {
  const base = fileName
    .replace(/[^a-zA-Z0-9]/g, "_")
    .replace(/^_+/, "")
    .replace(/^([0-9])/, "_$1");
  return `REF_${base || "FILE"}`;
};

const FRONT_MATTER_REGEX = /^---\n([\s\S]*?)\n---/;

function parseFrontMatter(source) {
  const match = source.match(FRONT_MATTER_REGEX);
  if (!match) {
    return {};
  }

  const lines = match[1].split(/\r?\n/);
  return lines.reduce((acc, line) => {
    const trimmed = line.trim();
    if (!trimmed || trimmed.startsWith("#")) {
      return acc;
    }
    const [key, ...rest] = trimmed.split(":");
    if (!key || rest.length === 0) {
      return acc;
    }
    const value = rest.join(":").trim();
    acc[key.trim()] = value.replace(/^"|"$/g, "");
    return acc;
  }, {});
}

const escapeMarkdown = (value) =>
  value
    .replace(/\|/g, "\\|")
    .replace(/\r?\n/g, " ")
    .trim();

function buildSkillTable(files, metadataMap) {
  const rows = files.map((file) => {
    const meta = metadataMap.get(file) ?? {};
    const title = meta.title ? escapeMarkdown(meta.title) : file;
    const summary = meta.description
      ? escapeMarkdown(meta.description)
      : `See references/${file}`;
    return `| **${title}** (\`references/${file}\`) | ${summary} |`;
  });

  return ["| Reference | Summary |", "| --- | --- |", ...rows].join("\n");
}

async function main() {
  try {
    await fs.access(referencesDir);
  } catch {
    throw new Error(`References directory not found at ${referencesDir}`);
  }

  try {
    await fs.access(skillPath);
  } catch {
    throw new Error(`SKILL.md not found at ${skillPath}`);
  }

  const files = (await collectMarkdownFiles(referencesDir)).sort((a, b) =>
    a.localeCompare(b),
  );

  const metadataByFile = new Map();
  for (const file of files) {
    const fullPath = path.join(referencesDir, file);
    const source = await fs.readFile(fullPath, "utf8");
    metadataByFile.set(file, parseFrontMatter(source));
  }

  const relativeSkillPath = path
    .relative(manifestDir, skillPath)
    .split(path.sep)
    .join("/");
  const importSkill = `import SKILL_DOCUMENT_RAW from "${relativeSkillPath}" with { type: "text" };`;
  const importReferences = files
    .map((file) => {
      const identifier = toIdentifier(file);
      const absoluteReferencePath = path.join(referencesDir, file);
      const relativeReferencePath = path
        .relative(manifestDir, absoluteReferencePath)
        .split(path.sep)
        .join("/");
      const sourcePath = relativeReferencePath;
      return `import ${identifier} from "${sourcePath}" with { type: "text" };`;
    })
    .join("\n");

  const referenceContentObject = files
    .map((file) => {
      const identifier = toIdentifier(file);
      return `  ${JSON.stringify(file)}: ${identifier},`;
    })
    .join("\n");

  const banner = "// Auto-generated by scripts/update-reference-manifest.mjs";
  const content = `${banner}
${importSkill}
${importReferences}

export const SKILL_DOCUMENT = SKILL_DOCUMENT_RAW;

export const REFERENCE_FILES = ${JSON.stringify(files, null, 2)} as const;

export type ReferenceFile = (typeof REFERENCE_FILES)[number];

export const REFERENCE_CONTENT: Record<ReferenceFile, string> = {
${referenceContentObject}
};
`;
  await fs.writeFile(manifestPath, content, "utf8");

  const skillDocument = await fs.readFile(skillPath, "utf8");
  const skillTable = buildSkillTable(files, metadataByFile);
  const startIndex = skillDocument.indexOf(SKILL_TABLE_START);
  const endIndex = skillDocument.indexOf(SKILL_TABLE_END);

  if (startIndex === -1 || endIndex === -1) {
    throw new Error(
      `SKILL.md is missing ${SKILL_TABLE_START} or ${SKILL_TABLE_END} markers`,
    );
  }

  const startInsertIndex = startIndex + SKILL_TABLE_START.length;
  const updatedSkill = `${skillDocument
    .slice(0, startInsertIndex)
    .trimEnd()}

${skillTable}

${skillDocument.slice(endIndex)}`;

  await fs.writeFile(skillPath, updatedSkill, "utf8");

  console.log(`Updated reference manifest with ${files.length} entries.`);
}

main().catch((error) => {
  console.error(error);
  process.exit(1);
});
